let gql,Comment,Tag,Post,pubsub;_e7c‍.x([["typeDefs",()=>typeDefs],["resolvers",()=>resolvers],["default",()=>_e7c‍.o]]);_e7c‍.w("apollo-server-express",[["gql",["gql"],function(v){gql=v}]]);_e7c‍.w("../../models/comment",[["default",["Comment"],function(v){Comment=v}]]);_e7c‍.w("../../models/tag",[["default",["Tag"],function(v){Tag=v}]]);_e7c‍.w("../../models/post",[["default",["Post"],function(v){Post=v}]]);_e7c‍.w("../../utils/pubsub",[["default",["pubsub"],function(v){pubsub=v}]]);





       const typeDefs = gql`
  type Mutation {
    createComment(postID: ID!, content: String!, tags: [String!]!): Comment
  }

  type Subscription {
    commentAdded: Comment!
  }
`

       const resolvers = {
  Mutation: {
    createComment: async (_root, { postID, content, tags }, { currentUser }) => {
      if (!currentUser) throw new AuthenticationError('not authenticated');

      const newComment = new Comment({
        post: postID,
        content,
        user: currentUser._id,
        tags,
        commentDate: new Date()
      })

      const { _id: id } = await newComment.save();

      const post = await Post.findById(postID);
      post.comments = [...post.comments, id];
      await post.save();

      currentUser.comments = [...currentUser.comments, id];
      await currentUser.save();

      await newComment.populate(
        [
          { path: 'user tags', select: '-comments -passwordHash' },
          { path: 'post', select: 'id' }
        ]
      );

      pubsub.publish('COMMENT_ADDED', { commentAdded: newComment });

      return newComment;
    }
  },
  Subscription: {
    commentAdded: {
      subscribe: () => pubsub.asyncIterator(['COMMENT_ADDED'])
    }
  }
}

_e7c‍.d({ typeDefs, resolvers });